#!/usr/bin/env node

/**
 * error-tracer.js
 * 
 * A tool to trace AGS runtime errors back to their source TypeScript files
 * using the source map generated by source-mapper.js.
 * 
 * Usage:
 * 1. Generate a source map: node source-mapper.js
 * 2. Run your app and pipe errors to this tool: ags run src/app.ts 2>&1 | node error-tracer.js
 */

const fs = require('fs');
const path = require('path');
const readline = require('readline');

// Configuration
const SOURCE_MAP_FILE = path.join(__dirname, 'logs/source-map.json');
const ERROR_LOG_FILE = path.join(__dirname, 'logs/last-error.log');

// Colors for terminal output
const colors = {
  reset: '\x1b[0m',
  red: '\x1b[31m',
  green: '\x1b[32m',
  yellow: '\x1b[33m',
  blue: '\x1b[34m',
  magenta: '\x1b[35m',
  cyan: '\x1b[36m',
  white: '\x1b[37m',
  bright: '\x1b[1m',
  dim: '\x1b[2m',
};

// Load the source map
let sourceMap;
try {
  sourceMap = JSON.parse(fs.readFileSync(SOURCE_MAP_FILE, 'utf-8'));
} catch (err) {
  console.error(`${colors.red}${colors.bright}Error: Could not load source map from ${SOURCE_MAP_FILE}`);
  console.error(`Run 'node source-mapper.js' first to generate a source map.${colors.reset}`);
  process.exit(1);
}

// Create logs directory if it doesn't exist
if (!fs.existsSync(path.join(__dirname, 'logs'))) {
  fs.mkdirSync(path.join(__dirname, 'logs'), { recursive: true });
}

// Set up readline interface
const rl = readline.createInterface({
  input: process.stdin,
  output: process.stdout,
  terminal: false
});

// Track error state
let inErrorBlock = false;
let errorLines = [];
let errorLogContent = [];

// Check source map for a symbol
function findInSourceMap(symbol) {
  // Try variables first
  if (sourceMap.variables[symbol]) {
    return {
      type: 'variable',
      location: sourceMap.variables[symbol]
    };
  }
  
  // Try functions
  if (sourceMap.functions[symbol]) {
    return {
      type: 'function',
      location: sourceMap.functions[symbol]
    };
  }
  
  // Try classes
  if (sourceMap.classes[symbol]) {
    return {
      type: 'class',
      location: sourceMap.classes[symbol]
    };
  }
  
  // Try components
  if (sourceMap.components[symbol]) {
    return {
      type: 'component',
      location: sourceMap.components[symbol]
    };
  }
  
  // Try JSX attributes (for signal errors like "No signal 'click' on object...")
  if (symbol.startsWith('on') && sourceMap.jsxAttributes[symbol]) {
    return {
      type: 'JSX attribute',
      locations: sourceMap.jsxAttributes[symbol]
    };
  }
  
  // Look at JSX tagnames (for errors like "No signal X on object 'AstalBox'")
  const tagName = symbol.replace('Astal', '');
  if (sourceMap.jsxTagnames[tagName] || sourceMap.jsxTagnames[tagName.toLowerCase()]) {
    return {
      type: 'JSX component tag',
      locations: sourceMap.jsxTagnames[tagName] || sourceMap.jsxTagnames[tagName.toLowerCase()]
    };
  }
  
  // Check for partial name matches (with numbers - common in bundled code)
  const baseSymbol = symbol.replace(/\d+$/, '');
  if (baseSymbol !== symbol) {
    // Try searching for the base symbol
    const result = findInSourceMap(baseSymbol);
    if (result) {
      return {
        type: result.type + ' (best guess)',
        location: result.location
      };
    }
  }
  
  // Check hotspots if we have a keyword
  if (symbol.includes('Variable') && sourceMap.hotspots['Variable']) {
    return {
      type: 'Variable usage (potential error spot)',
      locations: sourceMap.hotspots['Variable']
    };
  }
  
  if (symbol.includes('bind') && sourceMap.hotspots['bind']) {
    return {
      type: 'bind usage (potential error spot)',
      locations: sourceMap.hotspots['bind']
    };
  }
  
  if (symbol.includes('draw') && sourceMap.hotspots['draw-connect']) {
    return {
      type: 'draw signal connection (potential error spot)',
      locations: sourceMap.hotspots['draw-connect']
    };
  }
  
  if (symbol.includes('connect') && sourceMap.hotspots['connect']) {
    return {
      type: 'signal connection (potential error spot)',
      locations: sourceMap.hotspots['connect']
    };
  }
  
  return null;
}

// Extract symbol from error message
function extractSymbolFromError(errorMsg) {
  // Common error patterns
  const patterns = [
    /TypeError: (\w+) is not a function/,
    /(\w+) is not defined/,
    /cannot read property '.*' of (\w+)/,
    /(\w+) is not a constructor/,
    /cannot access property .* of (\w+)/,
    /No signal '(\w+)' on object '(\w+)'/ // This will capture both the signal and object
  ];
  
  for (const pattern of patterns) {
    const match = errorMsg.match(pattern);
    if (match && match[1]) {
      // Special handling for signal errors
      if (pattern.toString().includes("No signal")) {
        // Return both the signal name and object type
        // The first match is the signal (like "click")
        // The second match is the object (like "AstalBox")
        return {
          signal: match[1],
          object: match[2]
        };
      }
      return match[1];
    }
  }
  
  return null;
}

// Read a snippet of source code from a file
function readSourceSnippet(location) {
  const [filePath, lineNum] = location.split(':');
  const lineNumber = parseInt(lineNum, 10);
  
  try {
    const content = fs.readFileSync(filePath, 'utf-8');
    const lines = content.split('\n');
    
    // Extract a few lines before and after the target line
    const startLine = Math.max(0, lineNumber - 3);
    const endLine = Math.min(lines.length, lineNumber + 3);
    
    let snippet = '';
    for (let i = startLine; i < endLine; i++) {
      const prefix = i === lineNumber - 1 ? '> ' : '  ';
      const lineColor = i === lineNumber - 1 ? colors.bright + colors.yellow : '';
      snippet += `${colors.dim}${i + 1}:${colors.reset} ${lineColor}${prefix}${lines[i]}${colors.reset}\n`;
    }
    
    return snippet;
  } catch (err) {
    return `Could not read source file: ${filePath}`;
  }
}

// Process an error message
function processError(errorMsg) {
  console.log(`\n${colors.bright}${colors.red}╔══════════════════════════════════════════════════════╗`);
  console.log(`║ AGS ERROR ANALYZER                                   ║`);
  console.log(`╚══════════════════════════════════════════════════════╝${colors.reset}\n`);
  
  console.log(`${colors.yellow}Error message:${colors.reset} ${errorMsg}`);
  
  const extractedInfo = extractSymbolFromError(errorMsg);
  
  // Handle signal errors differently
  if (extractedInfo && typeof extractedInfo === 'object' && extractedInfo.signal) {
    console.log(`\n${colors.cyan}Signal error detected:${colors.reset}`);
    console.log(`- Signal: ${colors.bright}'${extractedInfo.signal}'${colors.reset}`);
    console.log(`- Object: ${colors.bright}'${extractedInfo.object}'${colors.reset}`);
    
    // First look for JSX attributes with the signal name (with 'on' prefix)
    const signalAttribute = 'on' + extractedInfo.signal.charAt(0).toUpperCase() + extractedInfo.signal.slice(1);
    console.log(`\n${colors.cyan}Looking for attribute:${colors.reset} ${signalAttribute}`);
    
    const attributeInfo = findInSourceMap(signalAttribute);
    if (attributeInfo) {
      console.log(`\n${colors.green}Found in source map!${colors.reset}`);
      console.log(`${colors.cyan}Type:${colors.reset} ${attributeInfo.type}`);
      
      if (attributeInfo.locations) {
        console.log(`${colors.cyan}Potential Locations:${colors.reset}`);
        attributeInfo.locations.slice(0, 5).forEach(loc => {
          console.log(`- ${loc}`);
          console.log(readSourceSnippet(loc));
        });
        
        if (attributeInfo.locations.length > 5) {
          console.log(`...and ${attributeInfo.locations.length - 5} more locations`);
        }
      }
    } else {
      console.log(`\n${colors.yellow}Attribute not found in source map.${colors.reset}`);
    }
    
    // Then look for the object
    console.log(`\n${colors.cyan}Looking for object:${colors.reset} ${extractedInfo.object}`);
    const objectInfo = findInSourceMap(extractedInfo.object);
    if (objectInfo) {
      console.log(`\n${colors.green}Found in source map!${colors.reset}`);
      console.log(`${colors.cyan}Type:${colors.reset} ${objectInfo.type}`);
      
      if (objectInfo.location) {
        console.log(`${colors.cyan}Location:${colors.reset} ${objectInfo.location}`);
        console.log(`\n${colors.cyan}Source code:${colors.reset}`);
        console.log(readSourceSnippet(objectInfo.location));
      } else if (objectInfo.locations) {
        console.log(`${colors.cyan}Potential Locations:${colors.reset}`);
        objectInfo.locations.slice(0, 5).forEach(loc => {
          console.log(`- ${loc}`);
          console.log(readSourceSnippet(loc));
        });
        
        if (objectInfo.locations.length > 5) {
          console.log(`...and ${objectInfo.locations.length - 5} more locations`);
        }
      }
    } else {
      console.log(`\n${colors.yellow}Object not found in source map.${colors.reset}`);
      
      // Suggest fixing the issue
      console.log(`\n${colors.cyan}Possible solutions:${colors.reset}`);
      console.log(`1. Check if the '${signalAttribute}' property is correctly defined in your component`);
      console.log(`2. Make sure the '${extractedInfo.object}' component supports the '${extractedInfo.signal}' signal`);
      console.log(`3. Use a 'setup' function instead of direct attribute for complex event handling`);
    }
  }
  // Handle regular errors
  else if (extractedInfo) {
    const symbol = extractedInfo;
    console.log(`\n${colors.cyan}Identified symbol:${colors.reset} ${symbol}`);
    
    const sourceInfo = findInSourceMap(symbol);
    if (sourceInfo) {
      console.log(`\n${colors.green}Found in source map!${colors.reset}`);
      console.log(`${colors.cyan}Type:${colors.reset} ${sourceInfo.type}`);
      
      if (sourceInfo.location) {
        console.log(`${colors.cyan}Location:${colors.reset} ${sourceInfo.location}`);
        console.log(`\n${colors.cyan}Source code:${colors.reset}`);
        console.log(readSourceSnippet(sourceInfo.location));
      } else if (sourceInfo.locations) {
        console.log(`${colors.cyan}Potential Locations:${colors.reset}`);
        sourceInfo.locations.slice(0, 5).forEach(loc => {
          console.log(`- ${loc}`);
          console.log(readSourceSnippet(loc));
        });
        
        if (sourceInfo.locations.length > 5) {
          console.log(`...and ${sourceInfo.locations.length - 5} more locations`);
        }
      }
    } else {
      console.log(`\n${colors.yellow}Symbol not found in source map.${colors.reset}`);
      
      // Search for similar symbols as a fallback
      const similarSymbols = Object.keys(sourceMap.variables)
        .concat(Object.keys(sourceMap.functions))
        .concat(Object.keys(sourceMap.classes))
        .concat(Object.keys(sourceMap.components))
        .filter(s => s.includes(symbol) || symbol.includes(s))
        .slice(0, 5);
      
      if (similarSymbols.length > 0) {
        console.log(`\n${colors.cyan}Similar symbols found:${colors.reset}`);
        similarSymbols.forEach(s => {
          const info = findInSourceMap(s);
          if (info && info.location) {
            console.log(`- ${s} (${info.type}): ${info.location}`);
          }
        });
      }
    }
  } else {
    console.log(`\n${colors.yellow}Could not identify a specific symbol in the error message.${colors.reset}`);
  }
  
  // Common AGS runtime errors and solutions
  console.log(`\n${colors.bright}${colors.blue}╔══════════════════════════════════════════════════════╗`);
  console.log(`║ COMMON FIXES                                         ║`);
  console.log(`╚══════════════════════════════════════════════════════╝${colors.reset}\n`);
  
  console.log(`${colors.cyan}1. Variable is not a function:${colors.reset}`);
  console.log(`   - Add 'new' before Variable constructor: ${colors.green}new Variable()${colors.reset}`);
  console.log(`   - Check imports: ${colors.green}import { Variable } from "astal"${colors.reset}`);
  
  console.log(`\n${colors.cyan}2. Binding issues:${colors.reset}`);
  console.log(`   - Check bind usage: ${colors.green}bind(someVar)${colors.reset}`);
  console.log(`   - Ensure Variable objects are created properly`);
  
  console.log(`\n${colors.cyan}3. Import errors:${colors.reset}`);
  console.log(`   - Use gi:// imports: ${colors.green}import Gtk from "gi://Gtk?version=4.0"${colors.reset}`);
  console.log(`   - Or use astal imports: ${colors.green}import { App } from "astal/gtk4"${colors.reset}`);
  
  console.log(`\n${colors.cyan}4. JSX Component errors:${colors.reset}`);
  console.log(`   - Check component prop types`);
  console.log(`   - Ensure all required props are provided`);
  
  console.log(`\n${colors.cyan}5. Signal errors (No signal 'X' on object 'Y'):${colors.reset}`);
  console.log(`   - Use setup function instead of direct signal attributes:`);
  console.log(`     ${colors.green}<box setup={(self) => { self.connect('button-press-event', ...) }} />${colors.reset}`);
  console.log(`   - Use astalify wrapper to handle signal connection:`);
  console.log(`     ${colors.green}export const Box = astalify(Gtk.Box, {...})${colors.reset}`);
  console.log(`   - Check if the component correctly exports signal handlers in its props type`);
  console.log(`   - For GTK4, use set_draw_func instead of connecting to 'draw' signal:`);
  console.log(`     ${colors.green}self.set_draw_func((widget, cr, width, height) => {...})${colors.reset}`);

  console.log(`\n${colors.magenta}Run this tool again with new errors for more analysis.${colors.reset}`);
}

// Main processing logic for each line of input
rl.on('line', (line) => {
  errorLogContent.push(line);
  
  // Detect start of error
  if (line.includes('Gjs-CRITICAL') || line.includes('JS ERROR')) {
    inErrorBlock = true;
    errorLines = [line];
    console.log(`${colors.red}${line}${colors.reset}`);
    return;
  }
  
  // Continue collecting error lines
  if (inErrorBlock) {
    errorLines.push(line);
    console.log(`${colors.red}${line}${colors.reset}`);
    
    // Check if this is the line with the error message
    if (line.includes('TypeError:') || line.includes('is not a function')) {
      // Process and analyze this error
      processError(line);
    }
    
    // End of error block
    if (line.includes('Module') && line.includes('threw an exception')) {
      inErrorBlock = false;
      
      // Write the error log to file for later reference
      fs.writeFileSync(ERROR_LOG_FILE, errorLogContent.join('\n'));
      console.log(`\n${colors.dim}Full error log saved to ${ERROR_LOG_FILE}${colors.reset}`);
    }
    return;
  }
  
  // Normal lines (pass through)
  console.log(line);
});

// Handle end of input
rl.on('close', () => {
  if (errorLines.length > 0) {
    console.log(`\n${colors.yellow}Session ended with errors.${colors.reset}`);
  } else {
    console.log(`\n${colors.green}Session ended with no detected errors.${colors.reset}`);
  }
});